<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0f">
<title>PostureGuard</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Bebas+Neue&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --border: #1e1e2e;
    --accent: #00ff88;
    --accent-dim: rgba(0,255,136,0.15);
    --warn: #ff6b35;
    --warn-dim: rgba(255,107,53,0.15);
    --text: #e8e8f0;
    --muted: #5a5a7a;
    --font-display: 'Bebas Neue', sans-serif;
    --font-body: 'DM Mono', monospace;
  }

  html, body {
    height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: var(--font-body);
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
  }

  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    padding: 24px 20px 36px;
    position: relative;
  }

  /* Background grid */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(0,255,136,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,255,136,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .app { position: relative; z-index: 1; width: 100%; max-width: 420px; display: flex; flex-direction: column; align-items: center; gap: 0; height: 100%; justify-content: space-between; }

  /* Header */
  .header {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding-top: 8px;
  }

  .logo {
    font-family: var(--font-display);
    font-size: 2.2rem;
    letter-spacing: 2px;
    color: var(--accent);
    line-height: 1;
    text-shadow: 0 0 20px rgba(0,255,136,0.4);
  }

  .logo span { color: var(--muted); }

  .status-pill {
    font-size: 0.65rem;
    letter-spacing: 1px;
    text-transform: uppercase;
    padding: 6px 12px;
    border-radius: 20px;
    border: 1px solid var(--border);
    color: var(--muted);
    background: var(--surface);
    transition: all 0.3s;
  }

  .status-pill.active { border-color: var(--accent); color: var(--accent); background: var(--accent-dim); }
  .status-pill.warning { border-color: var(--warn); color: var(--warn); background: var(--warn-dim); }

  /* Main display */
  .main-display {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    width: 100%;
  }

  /* Posture ring */
  .ring-container {
    position: relative;
    width: 200px;
    height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .ring-svg {
    position: absolute;
    inset: 0;
    transform: rotate(-90deg);
    transition: all 0.5s;
  }

  .ring-track {
    fill: none;
    stroke: var(--border);
    stroke-width: 6;
  }

  .ring-fill {
    fill: none;
    stroke: var(--accent);
    stroke-width: 6;
    stroke-linecap: round;
    stroke-dasharray: 534;
    stroke-dashoffset: 0;
    transition: stroke-dashoffset 0.5s ease, stroke 0.3s;
    filter: drop-shadow(0 0 6px rgba(0,255,136,0.6));
  }

  .ring-fill.bad { stroke: var(--warn); filter: drop-shadow(0 0 6px rgba(255,107,53,0.6)); }

  .ring-inner {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    z-index: 1;
  }

  .angle-display {
    font-family: var(--font-display);
    font-size: 3.5rem;
    line-height: 1;
    color: var(--accent);
    transition: color 0.3s;
    text-shadow: 0 0 20px rgba(0,255,136,0.3);
  }

  .angle-display.bad { color: var(--warn); text-shadow: 0 0 20px rgba(255,107,53,0.3); }
  .angle-label { font-size: 0.6rem; letter-spacing: 2px; color: var(--muted); text-transform: uppercase; }

  /* Posture message */
  .posture-message {
    font-family: var(--font-display);
    font-size: 1.4rem;
    letter-spacing: 3px;
    color: var(--accent);
    text-align: center;
    transition: color 0.3s;
    min-height: 2rem;
  }

  .posture-message.bad { color: var(--warn); }

  /* Stats row */
  .stats-row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
    width: 100%;
  }

  .stat-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 12px 8px;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .stat-value {
    font-family: var(--font-display);
    font-size: 1.6rem;
    color: var(--text);
    line-height: 1;
  }

  .stat-label {
    font-size: 0.55rem;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: var(--muted);
  }

  /* Threshold control */
  .threshold-section {
    width: 100%;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .threshold-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .threshold-title {
    font-size: 0.65rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
  }

  .threshold-value {
    font-family: var(--font-display);
    font-size: 1.2rem;
    color: var(--accent);
  }

  input[type=range] {
    width: 100%;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0,255,136,0.5);
  }

  /* Buttons */
  .btn-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    width: 100%;
  }

  .btn {
    font-family: var(--font-body);
    font-size: 0.7rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 16px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--muted);
    cursor: pointer;
    transition: all 0.2s;
    -webkit-tap-highlight-color: transparent;
  }

  .btn:active { transform: scale(0.97); }

  .btn.primary {
    border-color: var(--accent);
    color: var(--accent);
    background: var(--accent-dim);
    grid-column: span 2;
    font-size: 0.8rem;
    padding: 18px;
  }

  .btn.primary.monitoring {
    border-color: var(--warn);
    color: var(--warn);
    background: var(--warn-dim);
  }

  .btn.calibrate-btn {
    border-color: rgba(0,255,136,0.3);
    color: var(--accent);
  }

  /* Calibration overlay */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(10,10,15,0.95);
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 24px;
    padding: 40px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }

  .overlay.visible { opacity: 1; pointer-events: all; }

  .overlay-title {
    font-family: var(--font-display);
    font-size: 2.5rem;
    letter-spacing: 4px;
    color: var(--accent);
    text-align: center;
    text-shadow: 0 0 30px rgba(0,255,136,0.4);
  }

  .overlay-text {
    font-size: 0.75rem;
    color: var(--muted);
    text-align: center;
    line-height: 1.8;
    letter-spacing: 0.5px;
  }

  .countdown {
    font-family: var(--font-display);
    font-size: 5rem;
    color: var(--accent);
    text-shadow: 0 0 40px rgba(0,255,136,0.5);
    min-height: 80px;
    display: flex;
    align-items: center;
  }

  /* Vibration log */
  .vibe-log {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-height: 60px;
    overflow: hidden;
  }

  .vibe-entry {
    font-size: 0.6rem;
    color: var(--muted);
    letter-spacing: 1px;
    padding: 4px 8px;
    background: var(--surface);
    border-left: 2px solid var(--warn);
    border-radius: 0 4px 4px 0;
    animation: slideIn 0.3s ease;
  }

  @keyframes slideIn {
    from { opacity: 0; transform: translateX(-10px); }
    to { opacity: 1; transform: translateX(0); }
  }

  .pulse {
    animation: pulse 1s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  .no-sensor {
    text-align: center;
    color: var(--warn);
    font-size: 0.7rem;
    letter-spacing: 1px;
    line-height: 1.8;
    padding: 20px;
  }

  /* Diagnostic console */
  .diag-section {
    width: 100%;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .diag-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
  }

  .diag-title {
    font-size: 0.6rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
  }

  .diag-clear {
    font-size: 0.55rem;
    letter-spacing: 1px;
    color: var(--muted);
    background: none;
    border: none;
    cursor: pointer;
    text-transform: uppercase;
    font-family: var(--font-body);
    padding: 2px 6px;
  }

  .diag-log {
    max-height: 100px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 3px;
  }

  .diag-entry {
    font-size: 0.6rem;
    letter-spacing: 0.5px;
    line-height: 1.5;
    padding: 3px 6px;
    border-radius: 4px;
    border-left: 2px solid var(--muted);
    animation: slideIn 0.2s ease;
  }

  .diag-entry.info { border-color: var(--accent); color: rgba(0,255,136,0.8); background: rgba(0,255,136,0.05); }
  .diag-entry.error { border-color: var(--warn); color: rgba(255,107,53,0.9); background: rgba(255,107,53,0.05); }
  .diag-entry.warn { border-color: #f0c040; color: rgba(240,192,64,0.9); background: rgba(240,192,64,0.05); }

  .diag-indicators {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  .indicator {
    font-size: 0.55rem;
    letter-spacing: 1px;
    text-transform: uppercase;
    padding: 4px 8px;
    border-radius: 6px;
    border: 1px solid var(--border);
    color: var(--muted);
    background: var(--bg);
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .indicator::before {
    content: '';
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--muted);
    flex-shrink: 0;
  }

  .indicator.ok { border-color: rgba(0,255,136,0.3); color: var(--accent); }
  .indicator.ok::before { background: var(--accent); box-shadow: 0 0 6px rgba(0,255,136,0.6); }
  .indicator.fail { border-color: rgba(255,107,53,0.3); color: var(--warn); }
  .indicator.fail::before { background: var(--warn); }
</style>
</head>
<body>
<div class="app">

  <div class="header">
    <div class="logo">POSTURE<span>GUARD</span></div>
    <div class="status-pill" id="statusPill">STANDBY</div>
  </div>

  <div class="main-display">
    <div class="ring-container">
      <svg class="ring-svg" viewBox="0 0 180 180">
        <circle class="ring-track" cx="90" cy="90" r="85"/>
        <circle class="ring-fill" id="ringFill" cx="90" cy="90" r="85"/>
      </svg>
      <div class="ring-inner">
        <div class="angle-display" id="angleDisplay">--</div>
        <div class="angle-label">degrees off</div>
      </div>
    </div>

    <div class="posture-message" id="postureMessage">NOT MONITORING</div>
  </div>

  <div class="stats-row">
    <div class="stat-card">
      <div class="stat-value" id="alertCount">0</div>
      <div class="stat-label">Alerts</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="goodTime">0m</div>
      <div class="stat-label">Good Time</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="scoreDisplay">--</div>
      <div class="stat-label">Score</div>
    </div>
  </div>

  <div class="threshold-section">
    <div class="threshold-header">
      <div class="threshold-title">Sensitivity Threshold</div>
      <div class="threshold-value" id="thresholdDisplay">12Â°</div>
    </div>
    <input type="range" id="thresholdSlider" min="5" max="30" value="12" step="1">
    <div style="display:flex; justify-content:space-between; font-size:0.55rem; color:var(--muted); letter-spacing:1px;">
      <span>SENSITIVE</span><span>LENIENT</span>
    </div>
  </div>

  <div class="vibe-log" id="vibeLog"></div>

  <!-- Diagnostic Panel -->
  <div class="diag-section">
    <div class="diag-header">
      <div class="diag-title">Diagnostics</div>
      <button class="diag-clear" onclick="clearDiag()">Clear</button>
    </div>
    <div class="diag-indicators">
      <div class="indicator" id="indMotion">Motion API</div>
      <div class="indicator" id="indVibrate">Vibration</div>
      <div class="indicator" id="indContext">Secure ctx</div>
      <div class="indicator" id="indWakeLock">Wake Lock</div>
    </div>
    <div class="diag-log" id="diagLog"></div>
  </div>

  <div class="btn-row">
    <button class="btn primary" id="mainBtn" onclick="toggleMonitoring()">START MONITORING</button>
    <button class="btn calibrate-btn" onclick="startCalibration()">CALIBRATE</button>
    <button class="btn" onclick="resetStats()">RESET STATS</button>
  </div>

</div>

<!-- Calibration Overlay -->
<div class="overlay" id="calibOverlay">
  <div class="overlay-title">CALIBRATION</div>
  <div class="overlay-text">
    Strap the phone to your upper back.<br>
    Sit in your best upright posture.<br>
    Hold still while we calibrate.
  </div>
  <div class="countdown" id="countdown">3</div>
  <button class="btn" style="width:100%; max-width:280px;" onclick="cancelCalibration()">CANCEL</button>
</div>

<script>
// State
let monitoring = false;
let calibrated = false;
let baselineGravity = { x: 0, y: 0, z: 0 };
let currentAngle = 0;
let threshold = 12;
let alertCount = 0;
let goodSeconds = 0;
let totalSeconds = 0;
let lastVibTime = 0;
let vibCooldown = 8000;
let statsInterval = null;
let calTimeout = null;
let calInterval = null;
let sensorAvailable = false;
let motionEventReceived = false;
let lastReadings = [];

// DOM refs
const statusPill = document.getElementById('statusPill');
const angleDisplay = document.getElementById('angleDisplay');
const postureMessage = document.getElementById('postureMessage');
const ringFill = document.getElementById('ringFill');
const mainBtn = document.getElementById('mainBtn');
const thresholdSlider = document.getElementById('thresholdSlider');
const thresholdDisplay = document.getElementById('thresholdDisplay');
const calibOverlay = document.getElementById('calibOverlay');
const countdownEl = document.getElementById('countdown');
const vibeLog = document.getElementById('vibeLog');
const alertCountEl = document.getElementById('alertCount');
const goodTimeEl = document.getElementById('goodTime');
const scoreEl = document.getElementById('scoreDisplay');
const diagLog = document.getElementById('diagLog');

// â”€â”€ Diagnostic logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function diag(msg, type = 'info') {
  const now = new Date();
  const ts = now.getHours().toString().padStart(2,'0') + ':' +
             now.getMinutes().toString().padStart(2,'0') + ':' +
             now.getSeconds().toString().padStart(2,'0');
  const entry = document.createElement('div');
  entry.className = 'diag-entry ' + type;
  entry.textContent = '[' + ts + '] ' + msg;
  diagLog.insertBefore(entry, diagLog.firstChild);
  // Keep last 20 entries
  while (diagLog.children.length > 20) diagLog.removeChild(diagLog.lastChild);
  console.log('[PostureGuard][' + type + '] ' + msg);
}

function setIndicator(id, status, label) {
  const el = document.getElementById(id);
  if (!el) return;
  el.className = 'indicator ' + status;
  el.textContent = label;
}

function clearDiag() {
  diagLog.innerHTML = '';
  diag('Log cleared', 'info');
}

// â”€â”€ Capability checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkCapabilities() {
  // Secure context
  if (window.isSecureContext) {
    setIndicator('indContext', 'ok', 'Secure ctx âœ“');
    diag('Secure context: YES (' + window.location.protocol + ')', 'info');
  } else {
    setIndicator('indContext', 'fail', 'Secure ctx âœ—');
    diag('INSECURE CONTEXT: ' + window.location.protocol + '://' + window.location.host + ' â€” accelerometer will be blocked! Serve via HTTPS or localhost.', 'error');
  }

  // Vibration API
  if ('vibrate' in navigator) {
    setIndicator('indVibrate', 'ok', 'Vibration âœ“');
    diag('Vibration API: available', 'info');
  } else {
    setIndicator('indVibrate', 'fail', 'Vibration âœ—');
    diag('Vibration API: NOT available on this browser/device', 'error');
  }

  // DeviceMotion API
  if (typeof DeviceMotionEvent !== 'undefined') {
    setIndicator('indMotion', 'ok', 'Motion API âœ“');
    diag('DeviceMotionEvent: defined', 'info');
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
      diag('iOS permission model detected â€” will request permission', 'warn');
    } else {
      diag('Android/standard permission model â€” no explicit request needed', 'info');
    }
  } else {
    setIndicator('indMotion', 'fail', 'Motion API âœ—');
    diag('DeviceMotionEvent: NOT defined â€” no accelerometer support in this browser', 'error');
  }

  // Wake Lock
  if ('wakeLock' in navigator) {
    setIndicator('indWakeLock', 'ok', 'Wake Lock âœ“');
    diag('Wake Lock API: available', 'info');
    navigator.wakeLock.request('screen')
      .then(() => diag('Screen wake lock acquired â€” screen will stay on', 'info'))
      .catch(e => diag('Wake lock failed: ' + e.message, 'warn'));
  } else {
    setIndicator('indWakeLock', 'fail', 'Wake Lock âœ—');
    diag('Wake Lock API: not available â€” screen may sleep during monitoring', 'warn');
  }
}

// â”€â”€ Threshold slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
thresholdSlider.addEventListener('input', () => {
  threshold = parseInt(thresholdSlider.value);
  thresholdDisplay.textContent = threshold + 'Â°';
});

// â”€â”€ Sensor init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initSensor() {
  diag('Initialising motion sensor...', 'info');

  if (typeof DeviceMotionEvent === 'undefined') {
    diag('FATAL: DeviceMotionEvent undefined â€” accelerometer not supported', 'error');
    postureMessage.textContent = 'NO SENSOR';
    sensorAvailable = false;
    return;
  }

  if (!window.isSecureContext) {
    diag('FATAL: Page not in secure context â€” Chrome blocks sensors on file:// and plain http://', 'error');
    diag('Fix: serve via localhost (Termux) or HTTPS (Netlify Drop)', 'error');
    postureMessage.textContent = 'INSECURE CONTEXT';
    sensorAvailable = false;
    return;
  }

  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    // iOS 13+
    diag('Requesting iOS motion permission...', 'info');
    DeviceMotionEvent.requestPermission()
      .then(response => {
        diag('iOS permission response: ' + response, response === 'granted' ? 'info' : 'error');
        if (response === 'granted') {
          attachMotionListener();
        } else {
          diag('Permission denied by user â€” cannot access accelerometer', 'error');
          postureMessage.textContent = 'PERMISSION DENIED';
          sensorAvailable = false;
        }
      })
      .catch(e => {
        diag('iOS permission request threw: ' + e.name + ': ' + e.message, 'error');
        sensorAvailable = false;
      });
  } else {
    // Android / desktop
    attachMotionListener();
  }
}

function attachMotionListener() {
  diag('Attaching devicemotion listener...', 'info');
  window.addEventListener('devicemotion', handleMotion);
  sensorAvailable = true;

  // Check if we actually receive events within 2 seconds
  setTimeout(() => {
    if (!motionEventReceived) {
      diag('WARNING: No motion events received after 2s â€” sensor may be inactive, blocked, or device has no accelerometer', 'warn');
      setIndicator('indMotion', 'fail', 'Motion: no data');
    }
  }, 2000);

  diag('Motion listener attached â€” waiting for first event...', 'info');
}

// â”€â”€ Motion handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleMotion(event) {
  if (!motionEventReceived) {
    motionEventReceived = true;
    diag('First motion event received âœ“', 'info');
    setIndicator('indMotion', 'ok', 'Motion: live âœ“');

    // Log what fields are available
    const g = event.accelerationIncludingGravity;
    const a = event.acceleration;
    diag('accelerationIncludingGravity: ' + (g ? 'available' : 'NULL'), g ? 'info' : 'error');
    diag('acceleration (no gravity): ' + (a ? 'available' : 'null/unavailable'), 'info');
    if (g) diag('First raw reading: x=' + g.x?.toFixed(2) + ' y=' + g.y?.toFixed(2) + ' z=' + g.z?.toFixed(2), 'info');
  }

  const g = event.accelerationIncludingGravity;
  if (!g) {
    diag('accelerationIncludingGravity is null â€” cannot read sensor', 'error');
    return;
  }

  const { x, y, z } = g;
  if (x === null || y === null || z === null) {
    diag('Sensor returned null values (x=' + x + ' y=' + y + ' z=' + z + ')', 'warn');
    return;
  }

  // Smooth with rolling average
  lastReadings.push({ x, y, z });
  if (lastReadings.length > 10) lastReadings.shift();

  const avg = lastReadings.reduce((a, b) => ({ x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }), { x: 0, y: 0, z: 0 });
  const smooth = { x: avg.x / lastReadings.length, y: avg.y / lastReadings.length, z: avg.z / lastReadings.length };

  if (!calibrated || !monitoring) return;

  const dot = smooth.x * baselineGravity.x + smooth.y * baselineGravity.y + smooth.z * baselineGravity.z;
  const magA = Math.sqrt(smooth.x**2 + smooth.y**2 + smooth.z**2);
  const magB = Math.sqrt(baselineGravity.x**2 + baselineGravity.y**2 + baselineGravity.z**2);

  if (magA === 0 || magB === 0) {
    diag('Zero magnitude vector â€” skipping angle calculation', 'warn');
    return;
  }

  const cosAngle = Math.max(-1, Math.min(1, dot / (magA * magB)));
  currentAngle = Math.round(Math.acos(cosAngle) * (180 / Math.PI));

  updateDisplay(currentAngle);
  checkPosture(currentAngle);
}

// â”€â”€ Display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateDisplay(angle) {
  angleDisplay.textContent = angle;
  const isBad = angle > threshold;

  angleDisplay.className = 'angle-display' + (isBad ? ' bad' : '');
  ringFill.className = 'ring-fill' + (isBad ? ' bad' : '');

  const pct = Math.max(0, 1 - (angle / (threshold * 2)));
  ringFill.style.strokeDashoffset = 534 * (1 - pct);

  if (isBad) {
    postureMessage.textContent = 'CORRECT YOUR POSTURE';
    postureMessage.className = 'posture-message bad';
    statusPill.textContent = 'SLOUCHING';
    statusPill.className = 'status-pill warning';
  } else {
    postureMessage.textContent = 'POSTURE GOOD';
    postureMessage.className = 'posture-message';
    statusPill.textContent = 'MONITORING';
    statusPill.className = 'status-pill active';
  }
}

// â”€â”€ Posture check & vibration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkPosture(angle) {
  if (angle > threshold) {
    const now = Date.now();
    if (now - lastVibTime > vibCooldown) {
      triggerVibration();
      lastVibTime = now;
      alertCount++;
      alertCountEl.textContent = alertCount;
      logAlert(angle);
    }
  }
}

function triggerVibration() {
  if ('vibrate' in navigator) {
    const result = navigator.vibrate([200, 100, 200, 100, 400]);
    if (!result) {
      diag('vibrate() returned false â€” vibration may be muted or blocked', 'warn');
    }
  } else {
    diag('Vibration API not available â€” cannot buzz', 'error');
  }
}

function logAlert(angle) {
  const now = new Date();
  const ts = now.getHours().toString().padStart(2,'0') + ':' + now.getMinutes().toString().padStart(2,'0') + ':' + now.getSeconds().toString().padStart(2,'0');
  const entry = document.createElement('div');
  entry.className = 'vibe-entry';
  entry.textContent = ts + ' â€” ' + angle + 'Â° deviation';
  vibeLog.insertBefore(entry, vibeLog.firstChild);
  while (vibeLog.children.length > 3) vibeLog.removeChild(vibeLog.lastChild);
}

// â”€â”€ Toggle monitoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function toggleMonitoring() {
  if (!sensorAvailable) {
    diag('Cannot start: sensor not available â€” check diagnostics below', 'error');
    initSensor();
    return;
  }

  if (!calibrated) {
    diag('Cannot start: not calibrated yet â€” tap CALIBRATE first', 'warn');
    return;
  }

  monitoring = !monitoring;

  if (monitoring) {
    diag('Monitoring started (threshold: ' + threshold + 'Â°)', 'info');
    mainBtn.textContent = 'STOP MONITORING';
    mainBtn.classList.add('monitoring');
    statusPill.textContent = 'MONITORING';
    statusPill.className = 'status-pill active';
    postureMessage.textContent = 'MONITORING ACTIVE';

    statsInterval = setInterval(() => {
      totalSeconds++;
      if (currentAngle <= threshold) goodSeconds++;
      goodTimeEl.textContent = Math.floor(goodSeconds / 60) + 'm';
      scoreEl.textContent = Math.round((goodSeconds / totalSeconds) * 100) + '%';
    }, 1000);
  } else {
    diag('Monitoring stopped', 'info');
    mainBtn.textContent = 'START MONITORING';
    mainBtn.classList.remove('monitoring');
    statusPill.textContent = 'STANDBY';
    statusPill.className = 'status-pill';
    postureMessage.textContent = 'PAUSED';
    angleDisplay.textContent = '--';
    ringFill.style.strokeDashoffset = 0;
    clearInterval(statsInterval);
  }
}

// â”€â”€ Calibration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startCalibration() {
  if (!sensorAvailable) {
    diag('Sensor not available â€” initialising before calibration...', 'warn');
    initSensor();
    setTimeout(() => {
      if (sensorAvailable) startCalibration();
      else diag('Cannot calibrate: sensor still unavailable', 'error');
    }, 1000);
    return;
  }

  diag('Calibration started â€” sit upright and hold still', 'info');
  calibOverlay.classList.add('visible');
  let count = 3;
  countdownEl.textContent = count;
  countdownEl.classList.add('pulse');

  calInterval = setInterval(() => {
    count--;
    if (count > 0) {
      countdownEl.textContent = count;
    } else {
      countdownEl.textContent = 'ðŸ“';
      countdownEl.classList.remove('pulse');
      clearInterval(calInterval);

      if (lastReadings.length > 0) {
        const avg = lastReadings.reduce((a, b) => ({ x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }), { x: 0, y: 0, z: 0 });
        baselineGravity = {
          x: avg.x / lastReadings.length,
          y: avg.y / lastReadings.length,
          z: avg.z / lastReadings.length
        };
        calibrated = true;
        diag('Calibration complete â€” baseline: x=' + baselineGravity.x.toFixed(2) + ' y=' + baselineGravity.y.toFixed(2) + ' z=' + baselineGravity.z.toFixed(2), 'info');
        triggerVibration();
      } else {
        diag('CALIBRATION FAILED: no sensor readings available during calibration window', 'error');
        diag('Is the sensor working? Check Motion API indicator above', 'error');
      }

      calTimeout = setTimeout(() => {
        calibOverlay.classList.remove('visible');
        countdownEl.textContent = '3';
        if (calibrated) {
          postureMessage.textContent = 'CALIBRATED â€” READY';
          statusPill.textContent = 'CALIBRATED';
          statusPill.className = 'status-pill active';
        } else {
          postureMessage.textContent = 'CALIBRATION FAILED';
        }
      }, 800);
    }
  }, 1000);
}

function cancelCalibration() {
  clearInterval(calInterval);
  clearTimeout(calTimeout);
  calibOverlay.classList.remove('visible');
  countdownEl.textContent = '3';
  diag('Calibration cancelled by user', 'warn');
}

function resetStats() {
  alertCount = 0; goodSeconds = 0; totalSeconds = 0;
  alertCountEl.textContent = '0';
  goodTimeEl.textContent = '0m';
  scoreEl.textContent = '--';
  vibeLog.innerHTML = '';
  diag('Stats reset', 'info');
}

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.addEventListener('load', () => {
  diag('PostureGuard loading...', 'info');
  diag('User agent: ' + navigator.userAgent.substring(0, 80), 'info');
  checkCapabilities();
  initSensor();
});
</script>
</body>
</html>
